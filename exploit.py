from pwn import *
#import stitch

#['CRITICAL', 'DEBUG', 'ERROR', 'INFO', 'NOTSET', 'WARN', 'WARNING']
context.log_level = 'debug'
context.log_level = 'info'
#context.terminal = ['tmux', 'splitw', '-h']

sla = lambda token, *pays: [s.sendlineafter(token, str(pay)) for pay in pays]
sa = lambda token, *pays: [s.sendafter(token, str(pay)) for pay in pays]
p64 = lambda *x : flat(*x, word_size=64)
p32 = lambda *x : flat(*x, word_size=32)
pad64 = 0xffffffffffffffff
pad32 = 0xffffffff

def execmd(cmd):
    return subprocess.check_output(cmd, shell=True)

def solver() :
    s.interactive()

if __name__ == '__main__' :
    if len(sys.argv) == 1:
        #s = process(['./binary'], env={"LD_PRELOAD":"./libc.so.6"})
        #s = remote('localhost', 1234)
        s = process('./binary')
        pid = util.proc.pidof(s)
        log.info('pid = {}'.format(pid))
        pause()
    else :
        s = remote('kimtae.xyz', 1234)
    '''
    elf = ELF('bin')
    libc = ELF('libc')
    libc.address = leak
    elf.plt['printf']
    elf.got['printf']
    re.findall('[\w]{10}7f', dat.encode('hex'))[0].decode('hex').ljust(8, '\x00')
    libc.symbols['system']
    binsh = list(libc.search('/bin/sh'))[0]
    '''
    solver()

