from pwn import *
#import stitch

def logdebug() : exec( "context.log_level = 'debug'" )
def loginfo()  : exec( "context.log_level = 'info'" )
def logerror()  : exec( "context.log_level = 'error'" )
send = lambda *pays: [s.send(str(pay)) for pay in pays]
sendline = lambda *pays: [s.sendline(str(pay)) for pay in pays]
sendafter = lambda token, *pays: [s.sendafter(token, str(pay)) for pay in pays]
sendlineafter = lambda token, *pays: [s.sendlineafter(token, str(pay)) for pay in pays]
p64 = lambda *x : flat(*x, word_size=64)
p32 = lambda *x : flat(*x, word_size=32)
padd64 = p64(0xffffffffffffffff)
padd32 = p32(0xffffffff)
pause = lambda x='' : raw_input(log.info('Paused {}'.format(x)))
execmd = lambda cmd : subprocess.check_output(cmd, shell=True)

def solver() :
    s.interactive()

if __name__ == '__main__' :
    prob = 'prob'
    if len(sys.argv) == 1:
        s = process(prob)
        #s = process([prob], env={"LD_PRELOAD":"./libc.so.6"})
        #s = remote('localhost', 1234)
        pid = util.proc.pidof(s)[0]
        p_base = [s.libs()[d] for d in s.libs() if prob in d][0]
        l_base = [s.libs()[d] for d in s.libs() if 'libc' in d][0]
        log.info('pid = {}'.format(pid))
        log.info('proc_base = {}'.format(hex(p_base)))
        log.info('libc_base = {}'.format(hex(l_base)))
        debug=False
        if debug:
            context.terminal = ['tmux', 'splitw', '-h']
            execute = '''
            b *{}
            c
            '''.format(p_base)
            gdb.attach(pid, execute)
        else:   #in gdb -> source gd
            open('gd', 'w').write('''
            d
            d display
            attach {}
            '''.format(pid))

    else :
        s = remote('kimtae.xyz', 1234)
    pause()
    solver()
    '''
    elf = ELF(prob)
    libc = ELF(s.libs().keys()[0])  #local
    libc.address = leak
    elf.plt['printf']
    elf.got['printf']
    libc.symbols['system']
    binsh = list(libc.search('/bin/sh'))[0]
    '''
