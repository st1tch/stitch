from pwn import *
#import stitch

#['CRITICAL', 'DEBUG', 'ERROR', 'INFO', 'NOTSET', 'WARN', 'WARNING']
#context.log_level = 'debug'
#context.log_level = 'info'
#context.terminal = ['tmux', 'splitw', '-h']

def logdebug() : exec( "context.log_level = 'debug'" )
def loginfo()  : exec( "context.log_level = 'info'" )
sla = lambda *pays: [s.sendline(str(pay)) for pay in pays]
sa = lambda *pays: [s.send(str(pay)) for pay in pays]
p64 = lambda *x : flat(*x, word_size=64)
p32 = lambda *x : flat(*x, word_size=32)
pad64 = 0xffffffffffffffff
pad32 = 0xffffffff
pause = lambda x='' : raw_input(log.info('Paused {}'.format(x)))
execmd = lambda cmd : subprocess.check_output(cmd, shell=True)

def solver() :
    s.interactive()

if __name__ == '__main__' :
    if len(sys.argv) == 1:
        #s = process([prob], env={"LD_PRELOAD":"./libc.so.6"})
        #s = remote('localhost', 1234)
        prob = 'mutepig'
        s = process(prob)
        pid = util.proc.pidof(s)
        p_base = [s.libs()[d] for d in s.libs() if prob in d][0]
        l_base = [s.libs()[d] for d in s.libs() if 'libc' in d][0]
        log.info('pid = {}'.format(pid))
        log.info('proc_base = {}'.format(hex(p_base)))
        log.info('libc_base = {}'.format(hex(l_base)))
        pause()
    else :
        s = remote('kimtae.xyz', 1234)
    '''
    elf = ELF('bin')
    libc = ELF('libc')
    libc.address = leak
    elf.plt['printf']
    elf.got['printf']
    re.findall('[\w]{10}7f', dat.encode('hex'))[0].decode('hex').ljust(8, '\x00')
    libc.symbols['system']
    binsh = list(libc.search('/bin/sh'))[0]
    '''
    solver()
