from pwn import *
#import stitch

def logdebug() : exec( "context.log_level = 'debug'" )
def loginfo()  : exec( "context.log_level = 'info'" )
def logerror()  : exec( "context.log_level = 'error'" )
go1 = lambda *pays: [s.send(str(pay)) for pay in pays]
go2 = lambda *pays: [s.sendline(str(pay)) for pay in pays]
go3 = lambda token, *pays: [s.send(token, str(pay)) for pay in pays]
go4 = lambda token, *pays: [s.sendlineafter(token, str(pay)) for pay in pays]
p64 = lambda *x : flat(*x, word_size=64)
p32 = lambda *x : flat(*x, word_size=32)
pad64 = 0xffffffffffffffff
pad32 = 0xffffffff
pause = lambda x='' : raw_input(log.info('Paused {}'.format(x)))
execmd = lambda cmd : subprocess.check_output(cmd, shell=True)

def solver() :
    s.interactive()

if __name__ == '__main__' :
    if len(sys.argv) == 1:
        prob = 'prob'
        s = process(prob)
        #s = process([prob], env={"LD_PRELOAD":"./libc.so.6"})
        #s = remote('localhost', 1234)
        pid = util.proc.pidof(s)
        p_base = [s.libs()[d] for d in s.libs() if prob in d][0]
        l_base = [s.libs()[d] for d in s.libs() if 'libc' in d][0]
        log.info('pid = {}'.format(pid))
        log.info('proc_base = {}'.format(hex(p_base)))
        log.info('libc_base = {}'.format(hex(l_base)))
        debug=False
        if debug:
            context.terminal = ['tmux', 'splitw', '-h']
            execute = '''
            b *{}
            c
            '''.format(p_base+0x)
            gdb.attach(pid, execute)
    else :
        s = remote('kimtae.xyz', 1234)
    pause()
    solver()
    '''
    elf = ELF('bin')
    libc = ELF('libc')
    libc.address = leak
    elf.plt['printf']
    elf.got['printf']
    libc.symbols['system']
    re.findall('[\w]{10}7f', dat.encode('hex'))[0].decode('hex').ljust(8, '\x00')
    binsh = list(libc.search('/bin/sh'))[0]
    '''
